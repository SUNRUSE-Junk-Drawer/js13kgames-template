import * as path from "path"
import * as htmlMinifier from "html-minifier"
import BuildStage from "./buildStage"
import ReadJsonBuildStage from "./readJsonBuildStage"
import DeleteDirectoryBuildStage from "./deleteDirectoryBuildStage"
import CreateDirectoryBuildStage from "./createDirectoryBuildStage"
import WatchableBuildStage from "./watchableBuildStage"
import JavaScriptParseBuildStage from "./javaScriptParseBuildStage"
import javaScriptCompressors from "./javaScriptCompressors"
import zipCompressors from "./zipCompressors"
import WriteFileBuildStage from "./writeFileBuildStage"
import JavaScriptCombineBuildStage from "./javaScriptCombineBuildStage"
import JavaScriptParseGeneratedBuildStage from "./javaScriptParseGeneratedBuildStage";

class HtmlGeneratorBuildStage extends BuildStage {
  constructor(parent, name, javaScriptCombiner) {
    super(parent, name, [javaScriptCombiner], false)
    this.javaScriptCombiner = javaScriptCombiner
  }

  performStart() {
    this.html = htmlMinifier.minify(`
      <canvas id="c" style="position: fixed; left: 0; top: 0; width: 100%; height: 100%" />
      <script>${this.javaScriptCombiner.combined}</script>
    `, {
        caseSensitive: false,
        collapseBooleanAttributes: true,
        collapseInlineTagWhitespace: true,
        collapseWhitespace: true,
        conservativeCollapse: false,
        decodeEntities: true,
        html5: true,
        includeAutoGeneratedTags: false,
        keepClosingSlash: false,
        minifyCSS: true,
        minifyJS: false,
        minifyURLs: false,
        preserveLineBreaks: false,
        preventAttributesEscaping: false,
        processConditionalComments: false,
        removeAttributeQuotes: true,
        removeComments: true,
        removeEmptyAttributes: true,
        removeEmptyElements: true,
        removeOptionalTags: true,
        removeRedundantAttributes: true,
        removeScriptTypeAttributes: true,
        removeStyleLinkTypeAttributes: true,
        removeTagWhitespace: true,
        sortAttributes: true,
        sortClassName: true,
        trimCustomFragments: true,
        useShortDoctype: true
      })
    this.done()
  }
}

export default class GameBuildStage extends WatchableBuildStage {
  constructor(parent, name, engine) {
    super(parent, name, [], false)
    this.watches = []

    const metadata = new ReadJsonBuildStage(
      this,
      `metadata`,
      () => [`games`, name, `metadata.json`],
      []
    )

    const parseMetadata = new JavaScriptParseGeneratedBuildStage(this, `parseMetadata`, [metadata], `metadata.js`, () => `
      var beatsPerMinute = ${metadata.json.timing.beatsPerMinute}
      var ticksPerBeat = ${metadata.json.timing.ticksPerBeat}
      var beatsPerBar = ${metadata.json.timing.beatsPerBar}
      var targetAspectRatioHorizontally = ${metadata.json.targetAspectRatio.horizontally}
      var targetAspectRatioVertically = ${metadata.json.targetAspectRatio.vertically}
    `)

    this.watch(path.join(`games`, name, `metadata.json`), metadata, null)

    const createSrcDirectory = new CreateDirectoryBuildStage(this, `createSrcDirectory`, () => [`games`, name, `src`], [])

    const javaScriptParse = new JavaScriptParseBuildStage(this, `src`, [createSrcDirectory], false, () => [`games`, name, `src`])

    const zipCompressorInstances = []
    const htmlGeneratorInstances = []

    for (const javaScriptCompressor in javaScriptCompressors) {
      const combiner = new JavaScriptCombineBuildStage(
        this,
        javaScriptCompressor,
        [parseMetadata, engine, javaScriptParse],
        () => [
          [`metadata.js`],
          [`engine`, `video`, `webGlConstants.js`],
          [`engine`, `audio`, `context.js`],
          [`engine`, `video`, `context.js`],
          [`engine`, `audio`, `whiteNoise.js`]
        ]
      )
      const htmlGenerator = new HtmlGeneratorBuildStage(this, `generateHtmlFrom${javaScriptCompressor.slice(0, 1).toUpperCase()}${javaScriptCompressor.slice(1)}`, combiner)
      htmlGeneratorInstances.push(htmlGenerator)
      for (const zipCompressor in zipCompressors) {
        zipCompressorInstances.push(new zipCompressors[zipCompressor](this, javaScriptCompressor, htmlGenerator))
      }
    }

    const deleteDistDirectory = new DeleteDirectoryBuildStage(
      this,
      `deleteDistDirectory`,
      () => [`games`, name, `dist`],
      zipCompressorInstances.concat([metadata])
    )

    const createDistDirectory = new CreateDirectoryBuildStage(
      this,
      `createDistDirectory`,
      () => [`games`, name, `dist`],
      [deleteDistDirectory]
    )

    if (!this.oneOff()) {
      new WriteFileBuildStage(
        this,
        `writeHtml`,
        () => [`games`, name, `dist`, `index.html`],
        () => {
          let best = htmlGeneratorInstances[0]
          htmlGeneratorInstances.forEach(htmlGeneratorInstance => {
            if (htmlGeneratorInstance.html.length > best.html.length) {
              return
            }
            best = htmlGeneratorInstance
          })
          this.log(`Selected "${best.name}", writing...`)
          return best.html
        }, [createDistDirectory])
    }

    new WriteFileBuildStage(
      this,
      `writeZip`,
      () => [`games`, name, `dist`, `${metadata.json.applicationName}.zip`],
      () => {
        let best = zipCompressorInstances[0]
        zipCompressorInstances.forEach(zipCompressorInstance => {
          if (zipCompressorInstance.zipped.byteLength > best.zipped.byteLength) {
            return
          }
          best = zipCompressorInstance
        })
        this.log(`Selected "${best.name}", writing...`)
        return best.zipped
      }, [createDistDirectory])

    this.watchInstanced(path.join(`games`, name, `src`), javaScriptParse, `read`, null)
  }
}
